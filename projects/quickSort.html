<!DOCTYPE html>
<html>

  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title> Quick Sort | Robert Lamacraft </title>

    <!-- Favicon -->
    <link rel="icon" href="favicon.ico">
    <meta name="theme-color" content="#f5f7f7">
    <link rel="mask-icon" href="safari-pinned-tab.svg" color="#3CAA9C">

    <!-- Stylesheets -->
    <link href="../css/prism.css" rel="stylesheet">
    <link href="../css/style.css" rel="stylesheet">

    <link href='http://fonts.googleapis.com/css?family=Lato:300' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:300' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="../js/dark-theme.js"></script>
</head>

<body>
  <section class="content-section always-show">

    <div class="content-panel intro">
      <h2>Quick Sort</h2>
      <h4 class="subtitle">I ♥︎ QuickSort.</h4>
      <a href="/#homepage-content-section" class="btn header link">More Projects</a>
    </div>

    <div class="content-panel">
      <p>
        It feels like I have studied sorting algorithms half a dozen times: A Level Maths and Computing, some more times at uni. Quick sort has always been my favourite.
        Just something about the simple way it can be recursively implemented with just one condition and the arbitrary selection of the pivot. I just love it.
        Quite a few times I've coded simple implementations of it, just to learn syntax or compare different languages. So without further ado here is the extent of my nerdiness.
      </p>
    </div>

    <div class="content-panel">
      <h3>Haskell</h3>
      <p>
        First of all Haskell, can show how it is truly done. Nice and simple. Didn't even bother with the length-two-switch it's so simple and efficient. Though I'm sure some Haskell expert could make half-a-hundred improvements.
      </p>

      <pre class="line-numbers"><code class="language-haskell">quickSort :: [Float] -> [Float]
quickSort (n)
  | length n < 2    = n
  | otherwise       = quickSort (filter (&lt;pivot) n ) ++
                      [ pivot ] ++
                      quickSort (filter (&gt;pivot) n ) where
  pivot = head n</code></pre>
  </div>

  <div class="content-panel">
    <h3>Python</h3>

    <p>
      I do love Python. Just the little things like being able to concat an array with the <code class="inline">[pivot]</code> (compare that to Java, below)!
      So lovely and tidy, for an imperative/OOP language anyway.
    </p>

    <pre class="line-numbers"><code class="language-python">def quickSort(list):
  listLength = len(list)
  if listLength <= 1:
    return list
  elif listLength == 2:
    if list[0] < list[1]:
        return [list[0],list[1]]
    else:
        return [list[1],list[0]]
  else:
    pivot = list[0]
    list_S = []
    list_G = []
    for eachNum in range(1,listLength):
        if list[eachNum] < pivot:
            list_S.append(list[eachNum])
        else:
            list_G.append(list[eachNum])
    sorted_S = quickSort(list_S)
    sorted_G = quickSort(list_G)
    result = sorted_S + [pivot] + sorted_G
    return result</code></pre>
  </div>

    <div class="content-panel">
      <h3>Lua</h3>

      <p>
        Lua is a bit funky. The only form of arrays are associative arrays that map numeric indexes to values.
        To provide a sorted output a standard function, <code>table.sort()</code>, is provided that is an interface to the standard C math library.
          After a quick bit of research, it seems that the sort algorithm must by definition have a O(n log n) sort time which happens to equal that of QuickSort. Nice.
      </p>

      <pre class="line-numbers"><code class="language-lua">function listSort(list)
  table.sort(list)
  return(list)
end</code></pre>
    </div>

    <div class="content-panel">
      <h3>Swift</h3>

      <p>
        I first wrote the Swift version when it was a new language. Not sure if this is even best practice anymore; just fixed the changes Apple have made so it should still compile.
      </p>
      <p>
        One thing I do really like about Swift is the pre and post-conditions (line 2), really plays well with with my black-box determinstic function code-style. Wish Python had that.
      </p>

      <pre class="line-numbers"><code class="language-swift">func quickSort(list: [Float]) -> [Float] {
  let listLength = count(list)
  if listLength <= 1 {
    return list
  } else if listLength == 2 {
    if list[0] < list[1] {
        return [list[0],list[1]]
    } else {
        return [list[1],list[0]]
    }
  } else {
    let pivot = list[0]
    var list_S: [Float] = []
    var list_G: [Float] = []
    for(var eachNum = 0; eachNum < listLength; ++eachNum) {
        if list[eachNum] < pivot {
            list_S.append(list[eachNum])
        } else {
            list_G.append(list[eachNum])
        }
    }
    let sorted_S = quickSort(list_S)
    let sorted_G = quickSort(list_G)
    let result = sorted_S + [pivot] + sorted_G
    return result
  }
}</code></pre>
    </div>

    <div class="content-panel">
      <h3>Java</h3>

      <p>
        I strongly dislike Java. This code is in no way elegant. Why are there no primitive dynamic arrays???
        And is there <i>really</i> no better way to append two ArrayLists than the mess on lines 30 through 36. I hate Java. I really do.
        Maybe Java 8 will make it okay. (Just got to drag myself to check it out.)
      </p>

      <pre class="line-numbers"><code class="language-java">public static ArrayList<Float> quickSort(ArrayList<Float> list) {
  int listLength = list.size();
  if (listLength <= 1) {
    return list
  } else if (listLength == 2) {
    if (list.get(0) < list.get(1)) {
      return list;
    } else {
      ArrayList<Float> tmp = new ArrayList<Float>();
      tmp.add(list.get(1));
      tmp.add(list.get(0));
      return tmp;
    }
  } else {
    float pivot = list.get(0);
    ArrayList<Float> list_S = new ArrayList<Float>();
    ArrayList<Float> list_G = new ArrayList<Float>();
    for( int i = 1; i < listLength; i++ ) {
      if (list.get(i) < pivot) {
        list_S.add(list.get(i));
      } else {
        list_G.add(list.get(i));
      }
    }

    ArrayList<Float> sorted_S = quickSort(list_S);
    ArrayList<Float> sorted_G = quickSort(list_G);
    ArrayList<Float> result = new ArrayList<Float>();

    for (Float eachNum: sorted_S) {
      result.add(eachNum);
    }
    result.add(pivot);
    for (Float eachNum: sorted_G) {
      result.add(eachNum);
    }

    return result;
  }
}</code></pre>
      </div>

      <div class="content-panel outro">
        <a href="/#homepage-content-section" class="btn header link">More Projects</a>
      </div>

    </section>

    <script type="text/javascript" src="../js/jquery.min.js"></script>
    <script type="text/javascript" src="../js/prism.js"></script>
  </body>
</html>
